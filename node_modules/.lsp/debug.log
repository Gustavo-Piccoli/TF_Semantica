Hello - from c:\Users\gusta\.vscode\extensions\jaredly.reason-vscode-1.7.13\bin.native.exe.hot.exe
Previous log location: C:\Users\gusta\AppData\Local\Temp\lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///d%3A/Gustavo/Faculdade/1%20-%20Sem%C3%A2ntica/Trabalho%20Final/TF_Semantica/avaliador_e_typeinfer_atualizados_5.ml","languageId":"ocaml","version":1,"text":"(*Tipos de L1*)\r\ntype tipo = \r\n  | TyInt                   (* int *)      (* Tipo numero inteiro *)\r\n  | TyBool                  (* bool *)     (* Tipo booleano *)\r\n  | TyFn    of tipo * tipo  (* T1-->T2 *)  (* Tipo funcao *)\r\n  | TyPar   of tipo * tipo  (* T1*T2 *)    (* Tipo par *)\r\n  | TyList  of tipo         (* T list *)   (* Tipo Lista *)\r\n  | TyMaybe of tipo         (* maybe T*)   (* Tipo maybe*)\r\n\r\n(*Tipos de operacoes binarias*)\r\ntype bop = \r\n  | Soma                (* + *)\r\n  | Subtracao           (* - *)\r\n  | Multiplicacao       (* * *)\r\n  | Divisao             (* / *)\r\n  | Igual               (* == *)\r\n  | MaiorQue            (* > *)\r\n  | MenorQue            (* < *)\r\n  | MaiorOuIgual        (* >= *)\r\n  | MenorOuIgual        (* <= *)\r\n  | And                 (* && *)\r\n  | Or                  (* || *)\r\n\r\n(*Gramatica de L1*)\r\ntype expr =\r\n  | ExNum           of int                           (* Numero inteiro *)\r\n  | ExVar           of string                        (* Variavel *)\r\n  | ExTrue                                           (* Booleano true *)\r\n  | ExFalse                                          (* Booleano false *)\r\n  | ExIf            of expr * expr * expr            (* If then else *)\r\n  | ExFn            of string * tipo * expr          (* Funcao anonima *)\r\n  | ExApp           of expr * expr                   (* Aplicacao *)\r\n  | ExLet           of string * tipo * expr * expr   (* Funcao declarada *)\r\n  | ExLetRec        of string * tipo * expr * expr   (* Funcao declarada recursiva *)\r\n  | ExBinop         of bop * expr * expr             (* Operacao binaria *)\r\n  | ExPar           of expr * expr                   (* Par *)\r\n  | ExFst           of expr                          (* Primeiro elemento de um par *)\r\n  | ExSnd           of expr                          (* Segundo elemento de um par *)\r\n  | ExNil           of tipo                          (* Lista vazia *)\r\n  | ExList          of expr * expr                   (* Lista nao vazia *)\r\n  | ExHead          of expr                          (* Retorna o primeiro elemento de uma lista *)\r\n  | ExTail          of expr                          (* Retorna uma lista sem o primeiro elemento dela *)\r\n  | ExMatchList     of expr * expr * expr            (* Retorna expressoes diferentes dependendo se a lista for vazia ou nao*)\r\n  | ExJust          of expr                          (* *)\r\n  | ExNothing       of tipo                          (* *)\r\n  | ExMatchMaybe    of expr * expr * expr            (* *)\r\n\r\n(*Declaracao dos ambiente das expressoes*)\r\ntype ambiente_tipo = (string * tipo) list\r\n\r\n(* Valores *)\r\ntype valor =\r\n    VNum      of int                                        (* Numero inteiro *)\r\n  | VTrue                                                   (* Booleano true *)\r\n  | VFalse                                                  (* Booleano false *)\r\n  | VPar      of valor * valor                              (* Par *)\r\n  | VClos     of string * expr * ambiente_valor             (* Funcao anonima *)\r\n  | VRclos    of string * string * expr * ambiente_valor    (* Funcao declarada recursiva *)\r\n  | VNil      of tipo                                       (* Lista vazia *)\r\n  | VList     of valor * valor                              (* Lista nao vazia *)\r\n  | VJust     of valor                                      (* Maybe com valor *)\r\n  | VNothing  of tipo                                       (* Maybe vazio *)\r\nand \r\n  ambiente_valor = (string * valor) list\r\n\r\n(*Funcao polimorfica que ajuda a verificar todo o ambiente de uma expressao*)\r\nlet rec lookup a k = match a with\r\n  | [] -> None\r\n  | (y,i) :: tl -> if (y=k) then Some i else lookup tl k \r\n\r\n(*Funcao polimorfica que permite atualizar um ambiente de uma expressao*)\r\nlet rec update a k i = (k,i) :: a   \r\n\r\n(* Erro acionado caso uma expressao seja mal tipada*) \r\nexception TypeError\r\n\r\n(* Erro acionado caso o parser deixe passar uma expressao com erro de sintaxe*) \r\nexception BugParser\r\n\r\n(* Erro acionado caso o tipeinfer tenha deixado passar algum erro*) \r\nexception BugTypeInfer\r\n\r\n(* Erro acionado caso tente-se fazer uma divisao por zero*)\r\nexception ErroDivisaoZero\r\n\r\n(*Erro acionado quando algo nao tiver sido implementado*)\r\nexception NotImplemented\r\n\r\n\r\n(**************************************************************************************************************)\r\n(**************************************************Typeinfer***************************************************)\r\n(**************************************************************************************************************)\r\n\r\n(*Funcao que faz a inferencia de tipo de uma expressao da linguagem L1*)\r\nlet rec typeinfer (gamma: ambiente_tipo) (e:expr) : tipo  = match e with\r\n\r\n  (* Numero Inteiro *)\r\n  | ExNum _ -> TyInt\r\n\r\n  (* Variavel *)\r\n  | ExVar(x) -> (match lookup gamma x with\r\n      | Some t -> t\r\n      | None -> raise TypeError)\r\n\r\n  (* Booleano True *)\r\n  | ExTrue  -> TyBool\r\n\r\n  (* Booleano False *)\r\n  | ExFalse -> TyBool\r\n\r\n  (* If then else *)\r\n  | ExIf(e1,e2,e3) -> (match typeinfer gamma e1 with\r\n      | TyBool -> \r\n          let t2 = typeinfer gamma e2 in\r\n          let t3 = typeinfer gamma e3 in\r\n          if t2 = t3 then t2 \r\n          else raise TypeError \r\n      | _ -> raise TypeError) \r\n\r\n  (* Funcao Anonima *)\r\n  | ExFn(x,t,e1) -> let t1 = typeinfer (update gamma x t) e1 in TyFn(t,t1)\r\n  \r\n  (* Aplicacao *)\r\n  | ExApp(e1,e2) -> (match typeinfer gamma e1 with\r\n      | TyFn(t, t') ->  if (typeinfer gamma e2) = t then t' else raise TypeError\r\n      | _ -> raise TypeError)\r\n\r\n  (* Funcao Declarada *)\r\n  | ExLet(x,t,e1,e2) -> \r\n      if (typeinfer gamma e1) = t then typeinfer (update gamma x t) e2 else raise TypeError\r\n\r\n  (* Funcao Declarada Recursiva *)\r\n  | ExLetRec(f,(TyFn(t1,t2) as tf), ExFn(x,tx,e1), e2) ->\r\n      let gamma_tf = update gamma f tf in\r\n      let gamma_tf_tx = update gamma_tf x tx in\r\n      (if (typeinfer gamma_tf_tx e1) = t2 then typeinfer gamma_tf e2\r\n      else raise TypeError)\r\n\r\n  (* Funcao Declarada Recursiva *)\r\n  | ExLetRec _ -> raise BugParser\r\n\r\n  (* Operacao Binaria *)\r\n  | ExBinop(oper,e1,e2) ->\r\n      let t1 = typeinfer gamma e1 in\r\n      let t2 = typeinfer gamma e2 in\r\n      (if t1 = TyInt && t2 = TyInt then (match oper with\r\n          | Soma | Subtracao | Multiplicacao | Divisao -> TyInt\r\n          | Igual | MenorQue | MaiorQue | MaiorOuIgual | MenorOuIgual -> TyBool\r\n          | _ -> raise TypeError)\r\n      else if t1 = TyBool && t2 = TyBool then (match oper with\r\n          | And | Or -> TyBool\r\n          | _ -> raise TypeError)\r\n      else raise TypeError)\r\n\r\n  (* Par *)\r\n  | ExPar(e1,e2) -> TyPar(typeinfer gamma e1, typeinfer gamma e2) \r\n\r\n  (* Primeiro Elemento de um Par *)\r\n  | ExFst(e1) -> (match typeinfer gamma e1 with\r\n      | TyPar(t1,_) -> t1\r\n      | _ -> raise TypeError)\r\n\r\n  (* Segundo Elemento de um Par *)\r\n  | ExSnd(e1) -> (match typeinfer gamma e1 with\r\n      | TyPar(_,t2) -> t2\r\n      | _ -> raise TypeError)\r\n\r\n  (* Lista Vazia *)\r\n  | ExNil(t0) -> (match t0 with\r\n      | TyList(t1) -> TyList(t1)\r\n      | _ -> raise TypeError)\r\n\r\n  (* Lista com Elementos *)\r\n  | ExList(e1, e2) ->\r\n      let t1 = typeinfer gamma e1 in \r\n      let t2 = typeinfer gamma e2 in (match t2 with\r\n          | TyList(t3) -> if t1 = t3 then TyList(t1) else raise TypeError\r\n          | _ -> raise TypeError)\r\n\r\n  (* Primeiro Elemento de uma Lista*)\r\n  | ExHead(e0) -> (match e0 with\r\n      | ExList(e1, e2) -> let t0 = typeinfer gamma e0 in (match t0 with\r\n          | TyList(t1) -> t1\r\n          | _ -> raise TypeError)\r\n      | _ -> raise TypeError)\r\n\r\n  (* Segundo Elemento de uma Lista*)\r\n  | ExTail(e0) -> (match e0 with\r\n      | ExList(e1, e2) -> let t0 = typeinfer gamma e0 in (match t0 with\r\n          | TyList(t1) -> TyList(t1)\r\n          | _ -> raise TypeError)\r\n      | _ -> raise TypeError)\r\n\r\n  (* Verifica se a Lista e Vazia ou Nao*)\r\n  | ExMatchList(e1,e2,e3) ->\r\n      let t2 = typeinfer gamma e2 in\r\n      let t3 = typeinfer gamma e3 in\r\n      (if t2 = t3 then t2 else raise TypeError)\r\n\r\n  (* POSSIVELMENTE ERRADO*)\r\n  | ExJust(e0) -> TyMaybe(typeinfer gamma e0)\r\n    \r\n\r\n  (* POSSIVELMENTE ERRADO*)\r\n  | ExNothing(t) -> TyMaybe(t)\r\n\r\n  (* POSSIVELMENTE ERRADO*)\r\n  | ExMatchMaybe(e1,e2,e3) ->\r\n      let t2 = typeinfer gamma e2 in\r\n      let t3 = typeinfer gamma e3 in\r\n      (if t2 = t3 then t2 else raise TypeError)\r\n\r\n\r\n(**************************************************************************************************************)\r\n(**********************************************Avaliador Big Step**********************************************)\r\n(**************************************************************************************************************)\r\n\r\n(* Funcao que realiza as operacoes binarias*)\r\nlet faz_operacao (oper: bop) (v1: valor) (v2: valor) = match (oper, v1, v2) with\r\n  | (Soma, VNum(n1), VNum(n2)) -> VNum(n1 + n2)\r\n  | (Subtracao, VNum(n1), VNum(n2)) -> VNum(n1 - n2)\r\n  | (Multiplicacao, VNum(n1), VNum(n2)) -> VNum(n1 * n2)\r\n  | (Divisao, VNum(n1), VNum(n2)) -> if n2 = 0 then raise ErroDivisaoZero else VNum(n1 / n2)\r\n  | (Igual, VNum(n1), VNum(n2))  -> if (n1 = n2)  then VTrue else VFalse\r\n  | (MaiorQue, VNum(n1), VNum(n2))  -> if (n1 > n2)  then VTrue else VFalse\r\n  | (MenorQue, VNum(n1), VNum(n2))  -> if (n1 < n2)  then VTrue else VFalse\r\n  | (MaiorOuIgual, VNum(n1), VNum(n2)) -> if (n1 >= n2) then VTrue else VFalse\r\n  | (MenorOuIgual, VNum(n1), VNum(n2)) -> if (n1 <= n2) then VTrue else VFalse\r\n  | (And, VTrue, VTrue) -> VTrue\r\n  | (And, VTrue, VFalse) -> VFalse\r\n  | (And, VFalse, VTrue) -> VFalse\r\n  | (And, VFalse, VFalse) -> VFalse\r\n  | (Or, VTrue, VTrue) -> VTrue\r\n  | (Or, VTrue, VFalse) -> VTrue\r\n  | (Or, VFalse, VTrue) -> VTrue\r\n  | (Or, VFalse, VFalse) -> VFalse\r\n  | _ -> raise BugTypeInfer\r\n\r\n\r\n(* Funcao que faz apenas o passo big step*)\r\nlet rec eval (gamma:ambiente_valor) (e:expr) : valor = match e with\r\n\r\n  (* Numero Inteiro *)\r\n  | ExNum(n) -> VNum(n)\r\n\r\n  (* Variavel *)\r\n  | ExVar(x) -> (match lookup gamma x with\r\n      | Some v -> v\r\n      | None -> raise BugTypeInfer)\r\n\r\n  (* Booleano True *)\r\n  | ExTrue -> VTrue\r\n\r\n  (* Booleano False *)\r\n  | ExFalse -> VFalse\r\n\r\n  (* If then else *)\r\n  | ExIf(e1,e2,e3) -> (match eval gamma e1 with\r\n      | VTrue -> eval gamma e2\r\n      | VFalse -> eval gamma e3\r\n      | _ -> raise BugTypeInfer)\r\n\r\n  (* Funcao Anonima *)\r\n  | ExFn (x,_,e1) ->  VClos(x,e1,gamma)\r\n\r\n  (* Aplicacao *)\r\n  | ExApp(e1,e2) ->\r\n      let v1 = eval gamma e1 in\r\n      let v2 = eval gamma e2 in\r\n      (match v1 with\r\n        | VClos(x,ebdy,gamma') ->\r\n            let gamma'' = update gamma' x v2\r\n            in eval gamma'' ebdy\r\n        | VRclos(f,x,ebdy,gamma') ->\r\n            let gamma''  = update gamma' x v2 in\r\n            let gamma''' = update gamma'' f v1\r\n            in eval gamma''' ebdy\r\n        | _ -> raise BugTypeInfer)\r\n\r\n  (* Funcao Declarada *)\r\n  | ExLet(x,_,e1,e2) -> \r\n      let v1 = eval gamma e1 in\r\n      eval (update gamma x v1) e2\r\n\r\n  (* Funcao Declarada Recursiva *)\r\n  | ExLetRec(f,TyFn(t1,t2),ExFn(x,tx,e1), e2) when t1 = tx ->\r\n      let gamma'= update gamma f (VRclos(f,x,e1,gamma))\r\n      in eval gamma' e2\r\n\r\n  (* Funcao Declarada Recursiva *)\r\n  | ExLetRec _ -> raise BugParser\r\n\r\n  (* Operacao Binaria *)\r\n  | ExBinop(operador,e1,e2) ->\r\n      let v1 = eval gamma e1 in\r\n      let v2 = eval gamma e2 in\r\n      faz_operacao operador v1 v2\r\n\r\n  (* Par *)\r\n  | ExPar(e1,e2) ->\r\n      let v1 = eval gamma e1 in\r\n      let v2 = eval gamma e2 in\r\n      VPar(v1,v2)\r\n\r\n  (* Primeiro Elemento de um Par *)\r\n  | ExFst(e0) -> (match e0 with\r\n      | ExPar(e1,_) -> eval gamma e1\r\n      | _ -> raise BugTypeInfer)\r\n\r\n  (* Segundo Elemento de um Par *)\r\n  | ExSnd(e0) -> (match e0 with\r\n      | ExPar(_,e2) -> eval gamma e2\r\n      | _ -> raise BugTypeInfer)\r\n\r\n  (* Lista Vazia *)\r\n  | ExNil(t0) -> VNil(t0)\r\n\r\n  (* Lista com Elementos *)\r\n  | ExList(e1, e2) -> \r\n      let v1 = eval gamma e1 in\r\n      let v2 = eval gamma e2 in\r\n      VList(v1,v2)\r\n\r\n  (* Primeiro Elemento de uma Lista*)\r\n  | ExHead(e0) -> (match e0 with\r\n      | ExList(e1,_) -> eval gamma e1\r\n      | _ -> raise BugTypeInfer)\r\n\r\n  (* Segundo Elemento de uma Lista*)\r\n  | ExTail(e0) -> (match e0 with\r\n      | ExList(_,e2) -> eval gamma e2\r\n      | _ -> raise BugTypeInfer)\r\n\r\n  (* Verifica se a Lista e Vazia ou Nao*)\r\n  | ExMatchList(e0, e1, e2) -> (match eval gamma e0 with\r\n      | VNil(_) -> eval gamma e1\r\n      | VList(_,_) -> eval gamma e2\r\n      | _ -> raise BugTypeInfer)\r\n\r\n  (* Uma expressão just retorna um valor just *)\r\n  | ExJust(e0) -> VJust(eval gamma e0)\r\n\r\n  (* Uma expressão nothing retona um valor nothing *)\r\n  | ExNothing (t0) -> VNothing(t0)\r\n\r\n  (* Verifica se um tipo maybe é just ou nothing, e1 para just e e2 para nothing *)\r\n  | ExMatchMaybe(e0, e1, e2) -> (match eval gamma e0 with\r\n      | VJust(_) -> eval gamma e1\r\n      | VNothing(_) -> eval gamma e2\r\n      | _ -> raise BugTypeInfer)\r\n\r\n\r\n\r\n(**************************************************************************************************************)\r\n(************************************************ INTERPRETADOR ***********************************************)\r\n(**************************************************************************************************************)\r\n\r\n(* funcao que transforma um valor em um tipo*)\r\nlet rec valor_para_tipo (v: valor) : tipo = match v with\r\n  | VNum(n) -> TyInt\r\n  | VTrue -> TyBool\r\n  | VFalse -> TyBool\r\n  | VClos(x,e,gamma) -> TyFn(valor_para_tipo (eval gamma e), valor_para_tipo (eval gamma (ExVar(x))))\r\n  | VRclos(f,x,e,gamma) -> TyFn(valor_para_tipo (eval gamma e), valor_para_tipo (eval gamma (ExVar(x))))\r\n  | VPar(v1,v2) -> TyPar(valor_para_tipo v1, valor_para_tipo v2)\r\n  | VNil(t) -> TyList(t)\r\n  | VList(v1,v2) -> TyList(valor_para_tipo v1)\r\n  | VJust(v) -> TyMaybe(valor_para_tipo v)\r\n  | VNothing(t) -> TyMaybe(t)\r\n\r\n(* funcao que transforma um abiente de valores em uma ambiente de tipo*)\r\nlet rec ambiente_valor_para_ambiente_tipo (gamma: ambiente_valor) : ambiente_tipo = match gamma with\r\n  | [] -> []\r\n  | (x,v)::t -> (x,valor_para_tipo v)::(ambiente_valor_para_ambiente_tipo t)\r\n\r\n(* Função Auxiliar que Converte Tipo para String *)\r\nlet rec tipo_para_string (t:tipo) : string = match t with\r\n    | TyInt  -> \"int\"\r\n    | TyBool -> \"bool\"\r\n    | TyFn(t1,t2)   ->  \"(\"  ^ (tipo_para_string t1) ^ \" --> \" ^ (tipo_para_string t2) ^ \")\"\r\n    | TyPar(t1,t2) ->  \"(\"  ^ (tipo_para_string t1) ^ \" * \"   ^ (tipo_para_string t2) ^ \")\"\r\n    | TyList(t0) ->  \"[\"  ^ (tipo_para_string t0) ^ \"]\"\r\n    | TyMaybe(t0) ->  \"[\"  ^ (tipo_para_string t0) ^ \"]\"\r\n  \r\n(* Função Auxiliar que Converte Valor para String *)\r\nlet rec valor_para_string (v: valor) : string = match v with\r\n    | VNum n -> string_of_int n\r\n    | VTrue -> \"true\"\r\n    | VFalse -> \"false\"\r\n    | VPar(v1, v2) -> \"(\" ^ valor_para_string v1 ^ \",\" ^ valor_para_string v1 ^ \")\"\r\n    | VClos _ ->  \"fn\"\r\n    | VRclos _ -> \"fn\"\r\n    | VNil _ -> \"[]\"\r\n    | VList(v1, v2) -> \"[\" ^ valor_para_string v1 ^ \",\" ^ valor_para_string v2 ^ \"]\"\r\n    | VJust(v0) -> \"Just \" ^ valor_para_string v0\r\n    | VNothing _ -> \"Nothing\"\r\n\r\n(* Função Principal do Interpretador Sem Ambientes*)\r\nlet interpretador_sem_ambientes (e:expr) : unit =\r\n    try \r\n        let t = typeinfer [] e in\r\n        let v = eval [] e in\r\n        print_string ((valor_para_string v) ^ \" : \" ^ (tipo_para_string t))\r\n    with _ ->  print_string (\"erro \")\r\n\r\n(* Função Principal do Interpretador Com Ambientes*)\r\nlet interpretador_com_ambientes (a1:ambiente_valor) (e:expr) : unit =\r\n    let a2 = ambiente_valor_para_ambiente_tipo a1 in (\r\n    try \r\n        let t = typeinfer a2 e in\r\n        let v = eval a1 e in\r\n        print_string ((valor_para_string v) ^ \" : \" ^ (tipo_para_string t))\r\n    with _ ->  print_string (\"erro \"))"}}}
