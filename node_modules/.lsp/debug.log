Hello - from c:\Users\gusta\.vscode\extensions\jaredly.reason-vscode-1.7.13\bin.native.exe.hot.exe
Previous log location: C:\Users\gusta\AppData\Local\Temp\lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///d%3A/Gustavo/Faculdade/1%20-%20Sem%C3%A2ntica/Trabalho%20Final/TF_Semantica/Interpretador_L1.ml","languageId":"ocaml","version":1,"text":"(*Tipos de L1*)\r\ntype tipo = \r\n  | TyInt                   (* int *)      (*Tipo numero inteiro*)\r\n  | TyBool                  (* bool *)     (*Tipo booleano*)\r\n  | TyFn    of tipo * tipo  (* T1-->T2 *)  (*Tipo funcao*)\r\n  | TyPar   of tipo * tipo  (* T1*T2 *)    (*Tipo par*)\r\n  | TyList  of tipo         (* T list *)   (*Tipo Lista*)\r\n  | TyMaybe of tipo         (* maybe T *)   (*Tipo maybe*)\r\n\r\n(*Tipos de operacoes binarias*)\r\ntype bop = \r\n  | Soma                (* + *)\r\n  | Subtracao           (* - *)\r\n  | Multiplicacao       (* * *)\r\n  | Divisao             (* / *)\r\n  | Igual               (* == *)\r\n  | MaiorQue            (* > *)\r\n  | MenorQue            (* < *)\r\n  | MaiorOuIgual        (* >= *)\r\n  | MenorOuIgual        (* <= *)\r\n  | And                 (* && *)\r\n  | Or                  (* || *)\r\n\r\n(*Gramatica de L1*)\r\ntype expr =\r\n  | ExNum           of int                           (*Numero inteiro*)\r\n  | ExVar           of string                        (*Variavel*)\r\n  | ExTrue                                           (*Booleano true*)\r\n  | ExFalse                                          (*Booleano false*)\r\n  | ExIf            of expr * expr * expr            (*If then else*)\r\n  | ExFn            of string * tipo * expr          (*Funcao anonima*)\r\n  | ExApp           of expr * expr                   (*Aplicacao*)\r\n  | ExLet           of string * tipo * expr * expr   (*Funcao declarada*)\r\n  | ExLetRec        of string * tipo * expr * expr   (*Funcao declarada recursiva*)\r\n  | ExBinop         of bop * expr * expr             (*Operacao binaria*)\r\n  | ExPar           of expr * expr                   (*Par*)\r\n  | ExFst           of expr                          (*Primeiro elemento de um par*)\r\n  | ExSnd           of expr                          (*Segundo elemento de um par*)\r\n  | ExNil           of tipo                          (*Lista vazia*)\r\n  | ExList          of expr * expr                   (*Lista nao vazia*)\r\n  | ExHead          of expr                          (*Retorna o primeiro elemento de uma lista*)\r\n  | ExTail          of expr                          (*Retorna uma lista sem o primeiro elemento dela*)\r\n  | ExMatchList     of expr * expr * expr            (*Retorna expressoes diferentes dependendo se a lista for vazia ou nao*)\r\n  | ExJust          of expr                          (*Expressao Just de tipo maybe alguma coisa*)\r\n  | ExNothing       of tipo                          (*Expressao Nothing de tipo maybe alguma coisa*)\r\n  | ExMatchMaybe    of expr * expr * expr            (*Retorna expressoes diferentes dependendo se a expressao de tipo maybe for just ou nothing*)\r\n\r\n(*Declaracao dos ambiente das expressoes*)\r\ntype ambiente_tipo = (string * tipo) list\r\n\r\n(*Valores*)\r\ntype valor =\r\n    VNum               of int                                        (* Numero inteiro *)\r\n  | VTrue                                                            (* Booleano true *)\r\n  | VFalse                                                           (* Booleano false *)\r\n  | VPar               of valor * valor                              (* Par *)\r\n  | VClosure           of string * expr * ambiente_valor             (* Funcao anonima *)\r\n  | VClosureRecursivo  of string * string * expr * ambiente_valor    (* Funcao declarada recursiva *)\r\n  | VNil               of tipo                                       (* Lista vazia *)\r\n  | VList              of valor * valor                              (* Lista nao vazia *)\r\n  | VJust              of valor                                      (* Maybe com valor *)\r\n  | VNothing           of tipo                                       (* Maybe vazio *)\r\nand \r\n  ambiente_valor = (string * valor) list (*Declaracao dos ambiente de valores das expressoes*)\r\n\r\n(*Funcao polimorfica que ajuda a varre um ambiente em busca de uma variável de tipo ou de valor*)\r\nlet rec lookup ambiente identificador0 = match ambiente with\r\n  | [] -> None\r\n  | (identificador1,valor_ou_tipo) :: tail -> if (identificador1=identificador0) then Some valor_ou_tipo else lookup tail identificador0\r\n\r\n(*Funcao polimorfica que permite atualizar um ambiente com uma variável de tipo ou de valor*)\r\nlet rec update tail identificador tipo_ou_valor = (identificador,tipo_ou_valor) :: tail\r\n\r\n(*Erro acionado caso haja um problema na inferencia de tipo da expressao*) \r\nexception Erro_Typeinfer of string\r\n\r\n(*Erro acionado caso haja um problema na avaliação da expressao*) \r\nexception Erro_Eval of string\r\n\r\n\r\n\r\n(**************************************************************************************************************)\r\n(**************************************************Typeinfer***************************************************)\r\n(**************************************************************************************************************)\r\n\r\n(*Funcao que faz a inferencia de tipo de uma expressao da linguagem L1*)\r\nlet rec typeinfer (gamma: ambiente_tipo) (e:expr) : tipo  = match e with\r\n\r\n  (*Numero Inteiro*)\r\n  | ExNum _ -> TyInt\r\n\r\n  (*Variavel*) \r\n  | ExVar(x) -> (match lookup gamma x with\r\n      | Some t -> t\r\n      | None -> raise (Erro_Typeinfer (\"Variavel nao declarada\" ^ x)))\r\n\r\n  (*Booleano True*)\r\n  | ExTrue  -> TyBool\r\n\r\n  (*Booleano False*)\r\n  | ExFalse -> TyBool\r\n\r\n  (*If Then Else*) \r\n  | ExIf(e1,e2,e3) -> (match typeinfer gamma e1 with\r\n      | TyBool -> \r\n          if (typeinfer gamma e2) = (typeinfer gamma e3)\r\n          then typeinfer gamma e2\r\n          else raise (Erro_Typeinfer \"Em ExIf(e1,e2,e3), e2 e e3 tem tipos diferentes um do outro\")\r\n      | _ -> raise (Erro_Typeinfer \"Em ExIf(e1,e2,e3), e1 tem tipo diferente de booleano\"))\r\n\r\n  (*Funcao Anonima*) \r\n  | ExFn(x,t,e1) -> TyFn(t, (typeinfer(update gamma x t) e1))\r\n  \r\n  (*Aplicacao*)\r\n  | ExApp(e1,e2) -> (match typeinfer gamma e1 with\r\n      | TyFn(t1, t2) ->  if (typeinfer gamma e2) = t1 then t2 else raise (Erro_Typeinfer \"Em ExApp(ExFn(x,t,e1),e2) o tipo declarado t eh diferente do tipo da expressao e2\")\r\n      | _ -> raise (Erro_Typeinfer \"Em ExApp(e1,e2) a expressao e1 nao eh uma funcao\"))\r\n\r\n  (*Funcao Declarada*)\r\n  | ExLet(x,t,e1,e2) -> \r\n      if (typeinfer gamma e1) = t\r\n      then typeinfer (update gamma x t) e2\r\n      else raise (Erro_Typeinfer \"Em ExLet(x,t,e1,e2) o tipo da expressao e1 eh diferente do tipo declarado t\")\r\n\r\n  (*Funcao Declarada Recursiva*)\r\n  | ExLetRec(f, TyFn(t1,t2), ExFn(x,t3,e1), e2) when t1 = t3 -> (*t3 deve ser igual a t1*)\r\n      if (typeinfer (update (update gamma f (TyFn(t1,t2))) x t3) e1) = t2\r\n      then typeinfer (update gamma f (TyFn(t1,t2))) e2\r\n      else raise (Erro_Typeinfer \"ExLetRec(f, TyFn(t1,t2), ExFn(x,t3,e1), e2) o tipo declarado t3 eh diferente do tipo declarado t1\") \r\n\r\n  (*Operacao Binaria*)\r\n  | ExBinop(op,e1,e2) ->\r\n      let t1 = typeinfer gamma e1 in\r\n      let t2 = typeinfer gamma e2 in\r\n      (if (t1 = TyInt && t2 = TyInt) then (match op with\r\n          | Soma | Subtracao | Multiplicacao | Divisao -> TyInt\r\n          | Igual | MenorQue | MaiorQue | MaiorOuIgual | MenorOuIgual -> TyBool\r\n          | _ -> raise (Erro_Typeinfer \"Em ExBinop(op,e1,e2) o operador op eh invalido\"))\r\n      else if t1 = TyBool && t2 = TyBool then (match op with\r\n          | And | Or -> TyBool\r\n          | _ -> raise (Erro_Typeinfer \"Em ExBinop(op,e1,e2) o operador op eh invalido\"))\r\n      else raise (Erro_Typeinfer \"Em ExBinop(op,e1,e2) os tipos das expressoes e1 e e2 sao diferentes um do outro\"))\r\n\r\n  (*Par*)\r\n  | ExPar(e1,e2) -> TyPar(typeinfer gamma e1, typeinfer gamma e2) \r\n\r\n  (*Primeiro Elemento de um Par*)\r\n  | ExFst(e1) -> (match typeinfer gamma e1 with\r\n      | TyPar(t1,t2) -> t1\r\n      | _ -> raise (Erro_Typeinfer \"Em ExFst(e1) a expressao e1 nao eh do tipo par ordenado\"))\r\n\r\n  (*Segundo Elemento de um Par*)\r\n  | ExSnd(e1) -> (match typeinfer gamma e1 with\r\n      | TyPar(t1,t2) -> t2\r\n      | _ -> raise (Erro_Typeinfer \"Em ExSnd(e1) a expressao e1 nao eh do tipo par ordenado\"))\r\n\r\n  (*Lista Vazia*)\r\n  | ExNil(t0) -> (match t0 with\r\n      | TyList(t1) -> TyList(t1)\r\n      | _ -> raise (Erro_Typeinfer \"Em ExNil(t0) o tipo t0 nao eh do tipo lista\"))\r\n\r\n  (*Lista com Elementos*)\r\n  | ExList(e1, e2) -> (match typeinfer gamma e2 with\r\n      | TyList(t2) -> if (typeinfer gamma e1) = t2 then TyList(t2) else raise (Erro_Typeinfer \"Em ExList(e1, e2) o tipo da expressao e1 eh diferente do tipo da lista da expressao e2\")\r\n      | _ -> raise (Erro_Typeinfer \"Em ExList(e1, e2) a expressao e2 nao eh do tipo lista\"))\r\n\r\n  (*Primeiro Elemento de uma Lista*)\r\n  | ExHead(e0) -> (match typeinfer gamma e0 with\r\n      | TyList(t0) -> t0\r\n      | _ -> raise (Erro_Typeinfer \"Em ExHead(e0) a expressao e0 nao eh do tipo lista\"))\r\n\r\n  (*Segundo Elemento de uma Lista*)\r\n  | ExTail(e0) -> (match typeinfer gamma e0 with\r\n      | TyList(t0) -> TyList(t0)\r\n      | _ -> raise (Erro_Typeinfer \"Em ExTail(e0) a expressao e0 nao eh do tipo lista\"))\r\n\r\n  (*Match List*)\r\n  | ExMatchList(e1,e2,e3) ->\r\n      let t1 = typeinfer gamma e1 in\r\n      let t2 = typeinfer gamma e2 in\r\n      let t3 = typeinfer gamma e3 in (match t1 with\r\n        | TyList(t4) -> if t2 = t3 then t2 else raise (Erro_Typeinfer \"Em ExMatchList(e1,e2,e3) as expressoes e2 e e3 nao tem o mesmo tipo\")\r\n        | _ -> raise (Erro_Typeinfer \"Em ExMatchList(e1,e2,e3) a expressao e1 nao eh do tipo lista\"))\r\n\r\n  (*Just*)\r\n  | ExJust(e0) -> TyMaybe(typeinfer gamma e0)\r\n\r\n  (*Nothing*)\r\n  | ExNothing(t) -> TyMaybe(t)\r\n\r\n  (*Match Maybe*)\r\n  | ExMatchMaybe(e1,e2,e3) ->\r\n      let t1 = typeinfer gamma e1 in\r\n      let t2 = typeinfer gamma e2 in\r\n      let t3 = typeinfer gamma e3 in (match t1 with\r\n        | TyMaybe(t4) -> if t2 = t3 then t2 else (raise (Erro_Typeinfer \"Em ExMatchMaybe(e1,e2,e3) as expressoes e2 e e3 nao tem o mesmo tipo\"))\r\n        | _ -> raise (Erro_Typeinfer \"Em ExMatchMaybe(e1,e2,e3) a expressao e1 nao eh do tipo maybe\"))\r\n\r\n  (*Excecoes retornam erros*)\r\n  | _ -> raise (Erro_Typeinfer \"Expressao nao eh do tipo esperado\")\r\n\r\n\r\n(**************************************************************************************************************)\r\n(**********************************************Avaliador Big Step**********************************************)\r\n(**************************************************************************************************************)\r\n\r\n(*Funcao que realiza as operacoes binarias*)\r\nlet faz_operacao (oper: bop) (v1: valor) (v2: valor) = match (oper, v1, v2) with\r\n  | (Soma, VNum(n1), VNum(n2)) -> VNum(n1 + n2)\r\n  | (Subtracao, VNum(n1), VNum(n2)) -> VNum(n1 - n2)\r\n  | (Multiplicacao, VNum(n1), VNum(n2)) -> VNum(n1 * n2)\r\n  | (Divisao, VNum(n1), VNum(n2)) -> if n2 = 0 then raise (Erro_Eval \"A divisao por zero eh ilegal\") else VNum(n1 / n2)\r\n  | (Igual, VNum(n1), VNum(n2))  -> if (n1 = n2)  then VTrue else VFalse\r\n  | (MaiorQue, VNum(n1), VNum(n2))  -> if (n1 > n2)  then VTrue else VFalse\r\n  | (MenorQue, VNum(n1), VNum(n2))  -> if (n1 < n2)  then VTrue else VFalse\r\n  | (MaiorOuIgual, VNum(n1), VNum(n2)) -> if (n1 >= n2) then VTrue else VFalse\r\n  | (MenorOuIgual, VNum(n1), VNum(n2)) -> if (n1 <= n2) then VTrue else VFalse\r\n  | (And, VTrue, VTrue) -> VTrue\r\n  | (And, VTrue, VFalse) -> VFalse\r\n  | (And, VFalse, VTrue) -> VFalse\r\n  | (And, VFalse, VFalse) -> VFalse\r\n  | (Or, VTrue, VTrue) -> VTrue\r\n  | (Or, VTrue, VFalse) -> VTrue\r\n  | (Or, VFalse, VTrue) -> VTrue\r\n  | (Or, VFalse, VFalse) -> VFalse\r\n  | _ -> raise (Erro_Eval \"Operacao invalida\")\r\n\r\n\r\n(*Funcao que faz o passo big step*)\r\nlet rec eval (gamma:ambiente_valor) (e:expr) : valor = match e with\r\n\r\n  (*Numero Inteiro*)\r\n  | ExNum(n) -> VNum(n)\r\n\r\n  (*Variavel*) \r\n  | ExVar(x) -> (match lookup gamma x with\r\n      | Some v -> v\r\n      | None -> raise (Erro_Eval \"Variavel nao declarada\"))\r\n\r\n  (*Booleano True*)\r\n  | ExTrue -> VTrue\r\n\r\n  (*Booleano False*)\r\n  | ExFalse -> VFalse\r\n\r\n  (*If Then Else*)\r\n  | ExIf(e1,e2,e3) -> (match eval gamma e1 with\r\n      | VTrue -> eval gamma e2\r\n      | VFalse -> eval gamma e3\r\n      | _ -> raise (Erro_Eval \"Em ExIf(e1,e2,e3) a expressao e1 nao avalia para um valor booleano\"))\r\n\r\n  (*Funcao Anonima*) \r\n  | ExFn (x,t,e1) ->  VClosure(x,e1,gamma)\r\n\r\n  (*Aplicacao*)\r\n  | ExApp(e1,e2) -> (match eval gamma e1 with\r\n        | VClosure(x,e3,novo_gamma) -> eval (update novo_gamma x (eval gamma e2)) e3\r\n        | VClosureRecursivo(f,x,e3,novo_gamma) -> eval (update (update novo_gamma x (eval gamma e2)) f (eval gamma e1)) e3\r\n        | _ -> raise (Erro_Eval \"Em ExApp(e1,e2) a expressao e1 nao avalia para um valor closure\"))\r\n\r\n  (*Funcao Declarada*)\r\n  | ExLet(x,t,e1,e2) -> eval (update gamma x (eval gamma e1)) e2 \r\n\r\n  (*Funcao Declarada Recursiva*)\r\n  | ExLetRec(f,TyFn(t1,t2),ExFn(x,t3,e1), e2) when t1 = t3 -> eval (update gamma f (VClosureRecursivo(f,x,e1,gamma))) e2\r\n\r\n  (*Operacao Binaria*)\r\n  | ExBinop(op,e1,e2) ->\r\n      let v1 = eval gamma e1 in\r\n      let v2 = eval gamma e2 in\r\n      faz_operacao op v1 v2\r\n\r\n  (*Par*)\r\n  | ExPar(e1,e2) ->\r\n      let v1 = eval gamma e1 in\r\n      let v2 = eval gamma e2 in\r\n      VPar(v1,v2)\r\n\r\n  (*Primeiro Elemento de um Par*)\r\n  | ExFst(e0) -> (match e0 with\r\n      | ExPar(e1,_) -> eval gamma e1\r\n      | _ -> raise (Erro_Eval \"Em ExFst(e0) a expressao e0 nao avalia para um valor par ordenado\"))\r\n\r\n  (*Segundo Elemento de um Par*)\r\n  | ExSnd(e0) -> (match e0 with\r\n      | ExPar(_,e2) -> eval gamma e2\r\n      | _ -> raise (Erro_Eval \"Em ExSnd(e0) a expressao e0 nao avalia para um valor par ordenado\"))\r\n\r\n  (*Lista Vazia*)\r\n  | ExNil(t0) -> VNil(t0)\r\n\r\n  (*Lista com Elementos*)\r\n  | ExList(e1, e2) -> \r\n      let v1 = eval gamma e1 in\r\n      let v2 = eval gamma e2 in\r\n      VList(v1,v2)\r\n\r\n  (*Primeiro Elemento de uma Lista*)\r\n  | ExHead(e0) -> (match e0 with\r\n      | ExList(e1,_) -> eval gamma e1\r\n      | _ -> raise (Erro_Eval \"Em ExHead(e0) a expressao e0 nao avalia para um valor lista\"))\r\n\r\n  (*Segundo Elemento de uma Lista*)\r\n  | ExTail(e0) -> (match e0 with\r\n      | ExList(_,e2) -> eval gamma e2\r\n      | _ -> raise (Erro_Eval \"Em ExTail(e0) a expressao e0 nao avalia para um valor lista\"))\r\n\r\n  (*Verifica se a Lista e Vazia ou Nao*)\r\n  | ExMatchList(e0, e1, e2) -> (match eval gamma e0 with\r\n      | VNil(_) -> eval gamma e1\r\n      | VList(_,_) -> eval gamma e2\r\n      | _ -> raise (Erro_Eval \"Em ExMatchList(e0, e1, e2) a expressao e0 nao avalia para um valor lista\"))\r\n\r\n  (*Just*)\r\n  | ExJust(e0) -> VJust(eval gamma e0)\r\n\r\n  (*Nothing*)\r\n  | ExNothing (t0) -> VNothing(t0)\r\n\r\n  (*Match Maybe*)\r\n  | ExMatchMaybe(e0, e1, e2) -> (match eval gamma e0 with\r\n      | VJust(_) -> eval gamma e1\r\n      | VNothing(_) -> eval gamma e2\r\n      | _ -> raise (Erro_Eval \"Em ExMatchMaybe(e0, e1, e2) a expressao e0 nao avalia para um valor maybe\"))\r\n\r\n  (*Caso haja uma excecao, eh retornado um erro*)\r\n  | _ -> raise (Erro_Eval \"Expressao nao implementada\")\r\n\r\n\r\n(**************************************************************************************************************)\r\n(************************************************ INTERPRETADOR ***********************************************)\r\n(**************************************************************************************************************)\r\n\r\n(*Função Auxiliar que Converte Tipo para String *)\r\nlet rec tipo_para_string (t:tipo) : string = match t with\r\n    | TyInt  -> \"int\"\r\n    | TyBool -> \"bool\"\r\n    | TyFn(t1,t2)   ->  (tipo_para_string t1) ^ \" --> \" ^ (tipo_para_string t2)\r\n    | TyPar(t1,t2) ->  (tipo_para_string t1) ^ \" * \"   ^ (tipo_para_string t2)\r\n    | TyList(t0) ->  (tipo_para_string t0) ^ \" list\"\r\n    | TyMaybe(t0) ->  \"maybe \"  ^ (tipo_para_string t0)\r\n  \r\n(*Função Auxiliar que Converte Valor para String *)\r\nlet rec valor_para_string (v: valor) : string = match v with\r\n    | VNum n -> string_of_int n\r\n    | VTrue -> \"true\"\r\n    | VFalse -> \"false\"\r\n    | VPar(v1, v2) -> \"(\" ^ valor_para_string v1 ^ \",\" ^ valor_para_string v1 ^ \")\"\r\n    | VClosure _ ->  \"fn\"\r\n    | VClosureRecursivo _ -> \"fn\"\r\n    | VNil _ -> \"[]\"\r\n    | VList(v1, v2) -> \"[\" ^ valor_para_string v1 ^ \",\" ^ valor_para_string v2 ^ \"]\"\r\n    | VJust(v0) -> \"Just \" ^ valor_para_string v0\r\n    | VNothing _ -> \"Nothing\"\r\n\r\n(*Função Principal do Interpretador Sem Ambientes*)\r\nlet interpretador (e:expr) : unit =\r\n    try \r\n        let t = typeinfer [] e in\r\n        let v = eval [] e in\r\n        print_string ((valor_para_string v) ^ \" : \" ^ (tipo_para_string t))\r\n    with _ ->  print_string (\"erro \")"}}}
