Hello - from c:\Users\gusta\.vscode\extensions\jaredly.reason-vscode-1.7.13\bin.native.exe.hot.exe
Previous log location: C:\Users\gusta\AppData\Local\Temp\lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///d%3A/Gustavo/Faculdade/1%20-%20Sem%C3%A2ntica/Trabalho%20Final/TF_Semantica/LAB/avaliador_e_typeinfer_atualizados.ml","languageId":"ocaml","version":1,"text":"(*Tipos de L1*)\ntype tipo = \n  | TyInt                   (* int *)      (* Tipo numero inteiro *)\n  | TyBool                  (* bool *)     (* Tipo booleano *)\n  | TyFn    of tipo * tipo  (* T1-->T2 *)  (* Tipo funcao *)\n  | TyPar   of tipo * tipo  (* T1*T2 *)    (* Tipo par *)\n  | TyList  of tipo         (* T list *)   (* Tipo Lista *)\n  | TyMaybe of tipo         (* maybe T*)   (* Tipo maybe*)\n\n(*Tipos de operacoes binarias*)\ntype bop = \n  | Soma                (* + *)\n  | Subtracao           (* - *)\n  | Multiplicacao       (* * *)\n  | Divisao             (* / *)\n  | Igual               (* == *)\n  | MaiorQue            (* > *)\n  | MenorQue            (* < *)\n  | MaiorOuIgual        (* >= *)\n  | MenorOuIgual        (* <= *)\n  | And                 (* && *)\n  | Or                  (* || *)\n\n(*Gramatica de L1*)\ntype expr =\n  | ExNum           of int                           (* Numero inteiro *)\n  | ExVar           of string                        (* Variavel *)\n  | ExTrue                                           (* Booleano true *)\n  | ExFalse                                          (* Booleano false *)\n  | ExIf            of expr * expr * expr            (* If then else *)\n  | ExFn            of string * tipo * expr          (* Funcao anonima *)\n  | ExApp           of expr * expr                   (* Aplicacao *)\n  | ExLet           of string * tipo * expr * expr   (* Funcao declarada *)\n  | ExLetRec        of string * tipo * expr * expr   (* Funcao declarada recursiva *)\n  | ExBinop         of bop * expr * expr             (* Operacao binaria *)\n  | ExPar           of expr * expr                   (* Par *)\n  | ExFst           of expr                          (* Primeiro elemento de um par *)\n  | ExSnd           of expr                          (* Segundo elemento de um par *)\n  | ExNil           of tipo                          (* Lista vazia *)\n  | ExList          of expr * expr                   (* Lista nao vazia *)\n  | ExHead          of expr                          (* Retorna o primeiro elemento de uma lista *)\n  | ExTail          of expr                          (* Retorna uma lista sem o primeiro elemento dela *)\n  | ExMatchList     of expr * expr * expr            (* Retorna expressoes diferentes dependendo se a lista for vazia ou nao*)\n  | ExJust          of expr                          (* *)\n  | ExNothing       of tipo                          (* *)\n  | ExMatchMaybe    of expr * expr * expr            (* *)\n\n(*Declaracao dos ambiente das expressoes*)\ntype ambiente_tipo = (string * tipo) list\n\n(* Valores *) (* ADICIONAR O QUE ESTIVER FALTANDO*)\ntype valor =\n    VNum      of int\n  | VTrue\n  | VFalse\n  | VPar      of valor * valor\n  | VClos     of string * expr * ambiente_valor\n  | VRclos    of string * string * expr * ambiente_valor\n  | VNil                          (* POSSIVELMENTE ERRADO*)\n  | VList     of valor * valor    (* POSSIVELMENTE ERRADO*)\n  | VJust     of valor            (* POSSIVELMENTE ERRADO*)\n  | VNothing                      (* POSSIVELMENTE ERRADO*)\n  | VMaybe    of valor            (* POSSIVELMENTE ERRADO*)\n  \nand \n  ambiente_valor = (string * valor) list\n\n(*Funcao polimorfica que ajuda a verificar todo o ambiente de uma expressao*)\nlet rec lookup a k = match a with\n  | [] -> None\n  | (y,i) :: tl -> if (y=k) then Some i else lookup tl k \n\n(*Funcao polimorfica que permite atualizar um ambiente de uma expressao*)\nlet rec update a k i = (k,i) :: a   \n\n(* Erro acionado caso uma expressao seja mal tipada*) \nexception TypeError\n\n(* Erro acionado caso o parser deixe passar uma expressao com erro de sintaxe*) \nexception BugParser\n\n(* Erro acionado caso o tipeinfer tenha deixado passar algum erro*) \nexception BugTypeInfer\n\n(* Erro acionado caso tente-se fazer uma divisao por zero*)\nexception ErroDivisaoZero\n\n(*Erro acionado quando algo nao tiver sido implementado*)\nexception NotImplemented\n\n\n(**************************************************************************************************************)\n(**************************************************Typeinfer***************************************************)\n(**************************************************************************************************************)\n\n(*Funcao que faz a inferencia de tipo de uma expressao da linguagem L1*)\nlet rec typeinfer (gamma: ambiente_tipo) (e:expr) : tipo  = match e with\n\n  (* Numero Inteiro *)\n  | ExNum _ -> TyInt\n\n  (* Variavel *)\n  | ExVar x -> (match lookup gamma x with\n      | Some t -> t\n      | None -> raise TypeError)\n\n  (* Booleano True *)\n  | ExTrue  -> TyBool\n\n  (* Booleano False *)\n  | ExFalse -> TyBool\n\n  (* If then else *)\n  | ExIf(e1,e2,e3) -> (match typeinfer gamma e1 with\n      | TyBool -> \n          let t2 = typeinfer gamma e2 in\n          let t3 = typeinfer gamma e3 in\n          if t2 = t3 then t2 \n          else raise TypeError \n      | _ -> raise TypeError) \n\n  (* Funcao Anonima *)\n  | ExFn(x,t,e1) -> let t1 = typeinfer (update gamma x t) e1 in TyFn(t,t1)\n  \n  (* Aplicacao *)\n  | ExApp(e1,e2) -> (match typeinfer gamma e1 with\n      | TyFn(t, t') ->  if (typeinfer gamma e2) = t then t' else raise TypeError\n      | _ -> raise TypeError)\n\n  (* Funcao Declarada *)\n  | ExLet(x,t,e1,e2) -> \n      if (typeinfer gamma e1) = t then typeinfer (update gamma x t) e2 else raise TypeError\n\n  (* Funcao Declarada Recursiva *)\n  | ExLetRec(f,(TyFn(t1,t2) as tf), ExFn(x,tx,e1), e2) ->\n      let gamma_tf = update gamma f tf in\n      let gamma_tf_tx = update gamma_tf x tx in\n      (if (typeinfer gamma_tf_tx e1) = t2 then typeinfer gamma_tf e2\n      else raise TypeError)\n\n  (* Funcao Declarada Recursiva *)\n  | ExLetRec _ -> raise BugParser\n\n  (* Operacao Binaria *)\n  | ExBinop(oper,e1,e2) ->\n      let t1 = typeinfer gamma e1 in\n      let t2 = typeinfer gamma e2 in\n      (if t1 = TyInt && t2 = TyInt then (match oper with\n          | Soma | Subtracao | Multiplicacao | Divisao -> TyInt\n          | Igual | MenorQue | MaiorQue | MaiorOuIgual | MenorOuIgual -> TyBool\n          | _ -> raise TypeError)\n      else if t1 = TyBool && t2 = TyBool then (match oper with\n          | And | Or -> TyBool\n          | _ -> raise TypeError)\n      else raise TypeError)\n\n  (* Par *)\n  | ExPar(e1,e2) -> TyPar(typeinfer gamma e1, typeinfer gamma e2) \n\n  (* Primeiro Elemento de um Par *)\n  | ExFst e1 -> (match typeinfer gamma e1 with\n      | TyPar(t1,_) -> t1\n      | _ -> raise TypeError)\n\n  (* Segundo Elemento de um Par *)\n  | ExSnd e1 -> (match typeinfer gamma e1 with\n      | TyPar(_,t2) -> t2\n      | _ -> raise TypeError)\n\n  (* Lista Vazia *)\n  | ExNil(t) -> t\n\n  (* Lista com Elementos *)\n  | ExList(e1, e2) ->\n      let t1 = typeinfer gamma e1 in \n      let t2 = typeinfer gamma e2 in (match e2 with\n          | ExNil(_) | ExList(_) -> if t1 = t2 then t2 else raise TypeError \n          | _ -> raise TypeError)\n\n  (* Primeiro Elemento de uma Lista*)\n  | ExHead(e0) -> (match e0 with\n      | ExList(e1, e2) -> typeinfer gamma e0\n      | _ -> raise TypeError)\n\n  (* Segundo Elemento de uma Lista*)\n  | ExTail(e0) -> (match e with\n      | ExList(e1, e2) -> typeinfer gamma e0\n      | _ -> raise TypeError)\n\n  (* Verifica se a Lista e Vazia ou Nao*)\n  | ExMatchList(e1,e2,e3) ->\n      let t2 = typeinfer gamma e2 in\n      let t3 = typeinfer gamma e3 in\n      (if t2 = t3 then t2 else raise TypeError)\n\n  (* POSSIVELMENTE ERRADO*)\n  | ExJust(e0) -> typeinfer gamma e0 \n\n  (* POSSIVELMENTE ERRADO*)\n  | ExNothing(t) -> t\n\n  (* POSSIVELMENTE ERRADO*)\n  | ExMatchMaybe(e1,e2,e3) ->\n      let t2 = typeinfer gamma e2 in\n      let t3 = typeinfer gamma e3 in\n      (if t2 = t3 then t2 else raise TypeError)\n\n\n(**************************************************************************************************************)\n(**********************************************Avaliador Big Step**********************************************)\n(**************************************************************************************************************)\n\n(* Funcao que realiza as operacoes binarias*)\nlet faz_operacao (oper: bop) (v1: valor) (v2: valor) = match (oper, v1, v2) with\n  | (Soma, VNum(n1), VNum(n2)) -> VNum(n1 + n2)\n  | (Subtracao, VNum(n1), VNum(n2)) -> VNum(n1 - n2)\n  | (Multiplicacao, VNum(n1), VNum(n2)) -> VNum(n1 * n2)\n  | (Divisao, VNum(n1), VNum(n2)) -> if n2 = 0 then raise ErroDivisaoZero else VNum(n1 / n2)\n  | (Igual, VNum(n1), VNum(n2))  -> if (n1 = n2)  then VTrue else VFalse\n  | (MaiorQue, VNum(n1), VNum(n2))  -> if (n1 > n2)  then VTrue else VFalse\n  | (MenorQue, VNum(n1), VNum(n2))  -> if (n1 < n2)  then VTrue else VFalse\n  | (MaiorOuIgual, VNum(n1), VNum(n2)) -> if (n1 >= n2) then VTrue else VFalse\n  | (MenorOuIgual, VNum(n1), VNum(n2)) -> if (n1 <= n2) then VTrue else VFalse\n  | (And, VTrue, VTrue) -> VTrue\n  | (And, VTrue, VFalse) -> VFalse\n  | (And, VFalse, VTrue) -> VFalse\n  | (And, VFalse, VFalse) -> VFalse\n  | (Or, VTrue, VTrue) -> VTrue\n  | (Or, VTrue, VFalse) -> VTrue\n  | (Or, VFalse, VTrue) -> VTrue\n  | (Or, VFalse, VFalse) -> VFalse\n  | _ -> raise BugTypeInfer\n\n\n(* Funcao que faz apenas o passo big step*)\nlet rec eval (gamma:ambiente_valor) (e:expr) : valor = match e with\n\n  (* Numero Inteiro *)\n  | ExNum n -> VNum n\n\n  (* Variavel *)\n  | ExVar x -> (match lookup gamma x with\n      | Some v -> v\n      | None -> raise BugTypeInfer)\n\n  (* Booleano True *)\n  | ExTrue -> VTrue\n\n  (* Booleano False *)\n  | ExFalse -> VFalse\n\n  (* If then else *)\n  | ExIf(e1,e2,e3) -> (match eval gamma e1 with\n      | VTrue -> eval gamma e2\n      | VFalse -> eval gamma e3\n      | _ -> raise BugTypeInfer)\n\n  (* Funcao Anonima *)\n  | ExFn (x,_,e1) ->  VClos(x,e1,gamma)\n\n  (* Aplicacao *)\n  | ExApp(e1,e2) ->\n      let v1 = eval gamma e1 in\n      let v2 = eval gamma e2 in\n      (match v1 with\n        | VClos(x,ebdy,gamma') ->\n            let gamma'' = update gamma' x v2\n            in eval gamma'' ebdy\n        | VRclos(f,x,ebdy,gamma') ->\n            let gamma''  = update gamma' x v2 in\n            let gamma''' = update gamma'' f v1\n            in eval gamma''' ebdy\n        | _ -> raise BugTypeInfer)\n\n  (* Funcao Declarada *)\n  | ExLet(x,_,e1,e2) -> \n      let v1 = eval gamma e1 in\n      eval (update gamma x v1) e2\n\n  (* Funcao Declarada Recursiva *)\n  | ExLetRec(f,TyFn(t1,t2),ExFn(x,tx,e1), e2) when t1 = tx ->\n      let gamma'= update gamma f (VRclos(f,x,e1,gamma))\n      in eval gamma' e2\n\n  (* Funcao Declarada Recursiva *)\n  | ExLetRec _ -> raise BugParser\n\n  (* Operacao Binaria *)\n  | ExBinop(operador,e1,e2) ->\n      let v1 = eval gamma e1 in\n      let v2 = eval gamma e2 in\n      faz_operacao operador v1 v2\n\n  (* Par *)\n  | ExPar(e1,e2) ->\n      let v1 = eval gamma e1 in\n      let v2 = eval gamma e2 in\n      VPar(v1,v2)\n\n  (* Primeiro Elemento de um Par *)\n  | ExFst e0 -> (match e0 with\n      | ExPar(e1,_) -> eval gamma e1\n      | _ -> raise BugTypeInfer)\n\n  (* Segundo Elemento de um Par *)\n  | ExSnd e0 -> (match e0 with\n      | ExPar(_,e2) -> eval gamma e2\n      | _ -> raise BugTypeInfer)\n\n  (* Lista Vazia *)\n  | ExNil _ -> VNil\n\n  (* Lista com Elementos *)\n  | ExList(e1, e2) -> \n      let v1 = eval gamma e1 in\n      let v2 = eval gamma e2 in\n      VList(v1,v2)\n\n  (* Primeiro Elemento de uma Lista*)\n  | ExHead e0 -> (match e0 with\n      | ExList(e1,_) -> eval gamma e1\n      | _ -> raise BugTypeInfer)\n\n  (* Segundo Elemento de uma Lista*)\n  | ExTail e0 -> (match e0 with\n      | ExList(_,e2) -> eval gamma e2\n      | _ -> raise BugTypeInfer)\n\n  (* Verifica se a Lista e Vazia ou Nao*)\n  | ExMatchList(e0, e1, e2) ->\n      let v0 = eval gamma e0 in (match v0 with\n        | VNil -> eval gamma e1\n        | VList(_,_) -> eval gamma e2\n        | _ -> raise BugTypeInfer)\n\n  (* POSSIVELMENTE ERRADO*)\n  | ExJust e0 -> VJust(eval gamma e0)\n\n  (* POSSIVELMENTE ERRADO*)\n  | ExNothing _ -> VNothing\n\n  (* POSSIVELMENTE ERRADO*)\n  | ExMatchMaybe(e1, e2, e3) -> (match e1 with\n      | ExJust e0 -> eval gamma e2\n      | ExNothing _ -> eval gamma e3\n      | _ -> raise BugTypeInfer)\n\n\n\n(**************************************************************************************************************)\n(************************************************ INTERPRETADOR ***********************************************)\n(**************************************************************************************************************)\n\n(* Função Auxiliar que Converte Tipo para String *)\nlet rec tipo_para_string (t:tipo) : string = match t with\n    | TyInt  -> \"int\"\n    | TyBool -> \"bool\"\n    | TyFn(t1,t2)   ->  \"(\"  ^ (tipo_para_string t1) ^ \" --> \" ^ (tipo_para_string t2) ^ \")\"\n    | TyPar(t1,t2) ->  \"(\"  ^ (tipo_para_string t1) ^ \" * \"   ^ (tipo_para_string t2) ^ \")\"\n    | _ -> raise NotImplemented\n  \n(* Função Auxiliar que Converte Valor para String *)\nlet rec valor_para_string (v: valor) : string = match v with\n    | VNum n -> string_of_int n\n    | VTrue -> \"true\"\n    | VFalse -> \"false\"\n    | VPar(v1, v2) -> \"(\" ^ valor_para_string v1 ^ \",\" ^ valor_para_string v1 ^ \")\"\n    | VClos _ ->  \"fn\"\n    | VRclos _ -> \"fn\"\n    | _ -> raise NotImplemented\n  \n(* Função Principal do Interpretador \nlet interpretador (e:expr) : unit =\n    let t = typeinfer [] e in\n    let v = eval [] e in\n    print_string ((valor_para_string v) ^ \" : \" ^ (tipo_para_string t))*)\n\n(* Função Principal do Interpretador *)\nlet interpretador (e:expr) : unit =\n    try \n        let t = typeinfer [] e in\n        let v = eval [] e in\n        print_string ((valor_para_string v) ^ \" : \" ^ (tipo_para_string t))\n    with _ ->  print_string (\"erro \")"}}}
